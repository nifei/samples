原文在这里: http://www.agner.org/optimize/

# 1 介绍
这部手册是如下系列的第二部:

1. 优化c++软件: Windows, Linux 和 Mac 平台上的优化指南. 

2. 优化汇编语言的子程序: X86 平台的优化指南. 

3. Intel, AMD 和 VIA CPU 的微结构(*microarchicture*): 汇编程序员和编译器作者的指南. 

4. 指令表: Intel, AMD 和 VIA CPU 的指令背后的潜在操作, 数据吞吐量和指令操作分解. 

5. 不同 C++ 编译器和操作系统下的调用惯例. 

这些手册的最新版本在这里: http://www.agner.org/optimize/. 
版权说明在164页. 

这本手册解释了怎样把汇编代码和高级编程语言结合起来以及怎样使用汇编代码来优化 CPU 密集型代码的速度. 

这本手册面向高级汇编程序员和编译器作者. 读者最好已经了解汇编语言并且有一些汇编编程的经验. 建议初学者使用指南里介绍的优化技巧之前先搜索相关知识并获取一些编程经验. 我可以推荐一大堆互联网上的介绍, 手册, 论坛和讨论组 (在 http://www.agner.org/optimize/ 有列) 以及 R. C. Detmer 在2006年完成的这本书 "Introduction to 80x86 Assembly Language and Computer Archicture", 第二版. 

这本手册囊括了使用 x86  和 x86-64 指令集的左右平台. 大多数 Intel, AMD 和 VIA 的微处理器都使用这套指令集. 可以使用这套指令集的操作系统包括 DOS, Windows, Linux, FreeBSD/OpenBSD 和 Intel-Based Mac OS. 手册包含了最新的微处理器和指令集. 手册3和4介绍了个别微处理器模型的细节. 

比汇编语言更普适的优化技巧在手册1: "C++软件优化" 中有介绍. 个别微处理器的细节在手册3: "Intel, AMD 和 VIA CPU 的微结构" 有介绍. 指令表耗时(*tables of instruction timings*)等问题在手册4: "指令表: Intel, AMD 和 VIA CPU 的指令背后的潜在操作, 数据吞吐量和指令操作分解" 有介绍. 不同操作系统和编译器下的调用惯例在手册5: "不同 C++ 编译器和操作系统下的调用惯例" 中有讲. 

汇编语言变成比高级语言编程难多了. 犯错误很容易, 调试很难. 警告! 不要把你的程序问题发给我. 我不回复这类邮件. 如果在相关书籍和手册中找不到你要的答案的话, 互联网上多的是能解答你编程问题的论坛. 

纳秒征途好运!

## 1.1 使用汇编的理由
