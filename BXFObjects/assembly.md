原文在这里: http://www.agner.org/optimize/

# 1 介绍
这部手册是如下系列的第二部:

1. 优化c++软件: Windows, Linux 和 Mac 平台上的优化指南. 

2. 优化汇编语言的子程序: X86 平台的优化指南. 

3. Intel, AMD 和 VIA CPU 的微结构(*microarchicture*): 汇编程序员和编译器作者的指南. 

4. 指令表: Intel, AMD 和 VIA CPU 的指令背后的潜在操作, 数据吞吐量和指令操作分解. 

5. 不同 C++ 编译器和操作系统下的调用惯例. 

这些手册的最新版本在这里: http://www.agner.org/optimize/. 
版权说明在164页. 

这本手册解释了怎样把汇编代码和高级编程语言结合起来以及怎样使用汇编代码来优化 CPU 密集型代码的速度. 

这本手册面向高级汇编程序员和编译器作者. 读者最好已经了解汇编语言并且有一些汇编编程的经验. 建议初学者使用指南里介绍的优化技巧之前先搜索相关知识并获取一些编程经验. 我可以推荐一大堆互联网上的介绍, 手册, 论坛和讨论组 (在 http://www.agner.org/optimize/ 有列) 以及 R. C. Detmer 在2006年完成的这本书 "Introduction to 80x86 Assembly Language and Computer Archicture", 第二版. 

这本手册囊括了使用 x86  和 x86-64 指令集的所有平台. 大多数 Intel, AMD 和 VIA 的微处理器都使用这套指令集. 可以使用这套指令集的操作系统包括 DOS, Windows, Linux, FreeBSD/OpenBSD 和 Intel-Based Mac OS. 手册包含了最新的微处理器和指令集. 手册3和4介绍了个别微处理器模型的细节. 

比汇编语言更普适的优化技巧在手册1: "C++软件优化" 中有介绍. 个别微处理器的细节在手册3: "Intel, AMD 和 VIA CPU 的微结构" 有介绍. 指令表耗时(*tables of instruction timings*)等问题在手册4: "指令表: Intel, AMD 和 VIA CPU 的指令背后的潜在操作, 数据吞吐量和指令操作分解" 有介绍. 不同操作系统和编译器下的调用惯例在手册5: "不同 C++ 编译器和操作系统下的调用惯例" 中有讲. 

汇编语言变成比高级语言编程难多了. 犯错误很容易, 调试很难. 警告! 不要把你的程序问题发给我. 我不回复这类邮件. 如果在相关书籍和手册中找不到你要的答案的话, 互联网上多的是能解答你编程问题的论坛. 

纳秒征途好运!

## 1.1 使用汇编的理由
汇编语言如今不像过去用的那么多了. 但是还是有理由学习和使用它的. 主要是: 

1. 为了学习. 知道微处理器和编译器在指令层如何工作是很重要的, 这样我们就可以推测什么样的编程技巧最高效, 理解各种结构在高级语言中怎么工作的, 还可以追踪奇怪的错误. 

2. 为了调试和定位(verifying). 在查找错误和查看编译器能把一段特定代码优化成什么样的时候, 查看编译器生成的汇编代码或者调试器中的反汇编窗口很有帮助. 

3. 写编译器. 在开发编译器, 调试器和其他开发工具的时候, 理解汇编编程技巧是必需的.

4. 嵌入式系统. 小型嵌入式系统的资源和主机都比PC少. 为追求速度或体积在小型嵌入式系统上有必要使用汇编编程. 

5. 硬件驱动和系统编码. 使用高级编程语言访问硬件, 系统控制寄存器等有时很困难或者做不到. 

6. 获取使用高级语言无法获取的指令. 有些汇编指令没有对等的高级语言语句. 

7. 自修正代码. 自修正代码有时候因为干扰了高效率的代码缓存而显得不那么划算. 但它也可以变得有用, 例如在一个必需多次计算自定义方法的数学程序中包含一个小型编译器. 

8. 为空间优化代码. 如今的存储空间和内存如此廉价, 为减少代码量使用汇编语言已不再值当. 但缓存尺寸仍然是一块关键的资源, 我们要让它适合代码缓存的大小, 在某些情况下, 为此优化一段关键代码的尺寸还是有用的. 

9. 为速度优化代码. 多数情况下当代的C++编译器把代码优化得很好. 但有些情况下编译器仍然表现很差, 这时候小心使用汇编编程可以在速度上获得惊人的优化. 

10. 函数库. 优化很多程序员都在用的函数库获利更多. 

11. 让函数库和多编译器, 多操作系统兼容. 让有多个输入的函数库和不同的编译器和操作系统兼容是可能的. 这需要使用汇编编程. 

这本手册主要讨论优化代码速度, 其他几个方面也会讲下. 

## 1.2 不使用汇编代码的理由

汇编编程有许多缺陷和问题, 建议决定使用汇编代码来完成特定需求之前考虑其他方案. 最重要的几条不适用汇编编程理由有: 

1. 开发时间. 使用汇编语言写代码比使用高级语言花时间多了. 

2. 可靠性和安全性. 使用汇编代码很容易犯错误. 汇编编译器不会检查你有没有遵守调用惯例和寄存器保存惯例. 没人管你在所有分支和路径中加起来的push和pop指令数目是不是相同. 汇编代码搞出潜在错误的方法很多, 除非你有一套系统的方法测试和验证, 项目的可靠性和安全性都会受到影响. 

3. 调试和验证. 汇编代码更难调试和验证因为出错的可能性比高级语言多. 

4. 可维护性. 汇编代码也更难修改和维护, 因为这门语言允许没有结构的乱糟糟的代码存在, 还允许你使用别人都看不懂的卑鄙的技巧. (你造吗, 我自己第二天都看不懂了, o(s□t)o) 你需要完善的文档和可持续编程风格. (啥? o(>n<)o)

5. 系统代码可以使用伪指令函数(intrinsic functions)代替指令集. 最好的当代C++编译器提供伪指令函数来访问系统控制寄存器和其他系统指令. 伪指令函数可用时, 设备驱动和其他系统代码不再需要汇编代码了. 

6. 应用代码可以使用伪指令函数或者向量类代替汇编. 最好的当代C++编译器提供伪指令代码来实现向量操作和其他之前需要汇编编程的特殊指令. 为了利用SIMD的优越性, 我们不再非使用老式汇编代码不可了. 见34页. 

7. 可移植性. 